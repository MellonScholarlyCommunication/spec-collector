<pre class='metadata'>
Title: Collector
Shortname: collector
Level: 1
Status: LS
URL: https://mellonscholarlycommunication.github.io/spec-eventlog
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archiving](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, Ghent University, patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, Ghent University, ruben.dedecker@ugent.be
Editor: Jeroen Werbrouck, Ghent University, Jeroen.Werbrouck@ugent.be
Abstract: This document specifies the requirements for implementing and hosting an Artefact Lifecycle Event Log.
Markup Shorthands: markdown yes
</pre>

Set of documents {#set}
=======================

This document is one of the specifications produced by the **ResearcherPod** and **ErfgoedPod** project:

1. [Overview](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/)
3. [Data Pod](/spec-datapod/)
4. [Rule language](/spec-rulelanguage/)
5. [Artefact Lifecycle Event Log](/spec-eventlog/) (this document)

Introduction {#intro}
=====================
<img alt="…" src="mellon_collector_flow.png" style="width: 100%">
The Collector is an [=Autonomous Agent=] that traverses the scholarly network to gather artefact event information, both for lifecycle events and interaction events.
This collection happens by crawling the network based on the URI of a given artefact, and tries to retrieve as much information as possible regarding the artifact’s status, taking into account the actor's preferences of trusted sources. 
The Collector’s discovery process requires the materialization of three capabilities: selection, ranking, and verification of retrieved artifact event information.


# Definitions

This document uses the following defined terms from [[spec-overview#definitions]]:

- <dfn export>Autonomous Agent</dfn>
- <dfn export>Actor</dfn>
- <dfn export>Artefact</dfn>
- <dfn export>Maintainer</dfn>
- <dfn export>Data Pod</dfn>
- <dfn export>Lifecycle Event</dfn>
- <dfn export>Inbox</dfn>
- <dfn export>Artefact Lifecycle Event Log</dfn>
- <dfn export>Service Hub</dfn>
- <dfn export>Policy</dfn>
- <dfn export>Dashboard</dfn>

Collector interface {#initialization}
=================================================
A Collector instance requires a target URI and a set of lifecycle event data sources and associated trust scores to be passed on initialization.
Using these parameters, the collector automatically starts the lifecycle event collection process.
This provisioning MUST be possible using a PUT or POST to a dedicated [HTTP11] resource if the orchestrator is deployed as a web service; see § 10 Deploying an orchestrator. 



The Collection Process {#collecting}
=================================================
The Collector component gathers [=Artefact=] [=Lifecycle Event=] information in the decentralized scholarly communication network.
Based on the parameters passed on initialization, the component crawls the network for [Lifecycle Event=] information for a given artefact, or in case no artefact URI is passed, the component crawls the network for all available artefacts conform to the given filters at initialization.


## Selecting ## {#selecting}
The decentralized nature of the scholarly communication system has as a consequence that the scholarly record is distributed over the [=Researcher Pod=]'s on the network.
As it is often impossible to recreate a the full lifecycle of an artefact in a decentralied network, the collector has to decide on the sources it wants to crawl to retrieve the most relevant subset of the lifecycle trail of the target artefact. For this, it has to do source selection on the passed data sources, and on any discovered additional data sources while crawling the network.
This process makes use of [=smart filters=] to determine and select the most relevant and significant events as determined by the actor's preferences that initialized the collector instance.

The selection process is executed according to the following steps in case an artefact URI is given:
- Create a queue of all data sources and the passed target URI (When Given)
- Pop the highest ranked URI from the queue
- retrieve all Event information (relevant to the target URI)
- Add all found data sources to the queue
- repeat

## Ranking ## {#ranking}
Lifecycle events are discovered and ranked in order of the trustworthiness of their sources, as passed by the actor as paramters to the collector instance.
This information MUST be used to rank found [=Events=] and [=data sources=].
In case no value is given for the trustworthyness of a specific data source, a value can be derived from the trustworthyness of the previous data source in the chain combined with potential scoring by that data source of the currently retrieved data source.
This scoring mechanism MUST be configurable by the actor initializing the collector instance.
The result allows the ordering of data sources for confidence, and results in a list of lifecycle events ordered by time and confidence.

## Verifying ## {#verifying}
During or after their retrieval, the Collector should also verify the authenticity of event information, irrespective of their origin, to exclude and flag lifecycle events that were willingly or unwillingly corrupted. 
We define corruption as any truncation or alteration to an artifact or its metadata. 

Multiple methods of verification can be used:
- A first approach to verification of events is redundancy. By cross-referencing any found events with the events stored by the actor generating the event, the collector can assume that if a matching event can be discovered, the event can be presumed as not falisified.
- A second approach makes use of trusty URIs. Any event generated by another actor in the network can add the link to the original event using a trusty URI. On discovery of the event, the collector can check the origin of the event, and flag adaptations in the original. - this is not super useful, as this only protects against services altering the information in an event, and in case of a non-match you cannot really prove you have the original?
- Finally, digital signatures can be added to stored events. Digital signatures are currently in development in a W3C working group. Through digital signatures, the collector can verify the origin of an event by matching the signature for the event with the public key of the service that generated the event. This way the collector can verify the origin and contents of the event. (This does not require a lookup in the service event index to find a matching event).

<pre class="note">
  Note: 
  These mechanisms provide solutions for verifying the origin and contents of an event found in an event log.
  In case of an event not mentioned in the event log of an actor, the collector has no way of discovering this.
</pre>


Discovering the data source Event Log {#discovery}
=================================================
A Collector instance crawling the network for [=Artefact=] [=Lifecycle Event=] information, must be able to discover any [=Event Log=] defined by a discovered data source.
For this, any collector implementation must make use the Event Log Discovery step as defined in the [Event Log Specification](https://mellonscholarlycommunication.github.io/spec-eventlog/#discovery).



A source validation interface {#discovery}
=================================================
A Collector instance crawling the network for [=Artefact=] [=Lifecycle Event=] information, must be able to discover any [=Event Log=] defined by a discovered data source.
This discovery step requires the implementation of the following functionality:
- 


Deploying a collector {#deploying}
=================================================
A Collector MUST be deployable as a [=local background process=] or as a [=remote web service=].
In case of the latter, an actor SHOULD be able to spawn, initialize and trigger the instance over [[!HTTP11]].

<pre class="example">
POST /test HTTP/1.1
Host: collector.service
Content-Type: application/json
Accept: application/json

{
  target: "http://target.artefact.uri",
  datasources: {
    "http://data.source/1": 1,
    "http://data.source/2": .8,
    "http://data.source/3": .5,
    "http://data.source/4": 0,
  },
  filters: [
    ...
  ]
}

</pre>

If deployed as a local background process, an (custom) API MUST be present that is able perform these actions.








Appendix A: Implementation details {#implementation-details}
============================================================

## Retrieving inbox notifications

## Observing LDP resource state updates

## Time based trigger implementations


<pre class=biblio>
{
	"solid-oidc": {
		"authors": [
			"Aaron Coburn (Inrupt)",
			"elf Pavlik",
			"Dmitri Zagidulin"
		],
		"href": "https://solid.github.io/authentication-panel/solid-oidc/",
		"title": "SOLID-OIDC",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
	"solid-protocol": {
		"authors": [
			"Sarven Capadisli",
			"Tim Berners-Lee",
			"Ruben Verborgh",
			"Kjetil Kjernsmo",
			"Justin Bingham",
			"Dmitri Zagidulin"
		],
		"href": "https://solidproject.org/TR/protocol/",
		"title": "The Solid Protocol",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
  "spec-overview": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-overview/",
		"title": "Overview of the ResearcherPod specifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-rulelanguage": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-rulelanguage/",
		"title": "Rule language for decentralized business processes",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-notifications": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-notifications/",
		"title": "List of notifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "cron": {
		"authors": ["The Open Group"
    ],
		"href": "https://pubs.opengroup.org/onlinepubs/9699919799/",
		"title": "crontab - schedule periodic background work",
		"status": "Standard",
		"publisher": "IEEE"
	}
}
</pre>